<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Optimization • wheretowork</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Optimization">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">wheretowork</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/wheretowork.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-advanced-topics" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Advanced topics</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-advanced-topics">
<li><a class="dropdown-item" href="../articles/wtw_data.html">Data</a></li>
    <li><a class="dropdown-item" href="../articles/wtw_theory.html">Theory</a></li>
    <li><a class="dropdown-item" href="../articles/wtw_optimization.html">Optimization</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/NCC-CNC/wheretowork/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Optimization</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/NCC-CNC/wheretowork/blob/HEAD/vignettes/wtw_optimization.Rmd" class="external-link"><code>vignettes/wtw_optimization.Rmd</code></a></small>
      <div class="d-none name"><code>wtw_optimization.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>This article is intended for users already familiar with the basic
functionality of the <em>Where to Work</em> tool. It is recommended to
first read the <a href="wheretowork.html">official manual</a> before
proceeding.</p>
<p>The goal of this article is to provide an understanding of the
optimization procedures that the <em>Where to Work</em> tool uses to
generate prioritizations. Specifically, the <em>Where to Work</em> tool
uses the <a href="https://prioritizr.net/" class="external-link">prioritizr R package</a> to
generate prioritizations with exact algorithm solvers (i.e., <a href="https://www.gurobi.com/" class="external-link">Gurobi</a> and <a href="https://github.com/coin-or/Cbc" class="external-link">CBC</a>. Briefly, this article
will (i) provide an overview of exact algorithms, (ii) discuss the
advantages and disadvantageous of exact algorithms, (iii) provide an
explanation for how one exact algorithm works (i.e., the branch and
bound algorithm), and (iv) provide resources for learning more about
these exact algorithms. Although it is beyond the scope of this article
to provide a detailed understanding of the inner workings of all exact
algorithms, this article intends to provide enough information so that
users of the <em>Where to Work</em> tool can feel comfortable using
these algorithms.</p>
</div>
<div class="section level2">
<h2 id="overview-of-exact-algorithms">Overview of exact algorithms<a class="anchor" aria-label="anchor" href="#overview-of-exact-algorithms"></a>
</h2>
<p>Exact algorithms are a class of algorithms that guarantee optimality
<span class="citation">(A. S. L. Rodrigues &amp; Gaston, 2002;
Underhill, 1994)</span>. There are many different algorithms that are
classified as exact algorithms, including the branch and bound algorithm
<span class="citation">(Land &amp; Doig, 1960)</span>, branch and cut
algorithm <span class="citation">(Padberg &amp; Giovanni, 1991)</span>,
simplex algorithm <span class="citation">(Dantzig, 1951)</span>, and
interior point algorithm <span class="citation">(Dikin, 1967)</span>.
Broadly speaking, exact algorithms can solve various types of
optimization problems. For example, the simplex algorithm can solve
linear optimization problems that contain only continuous decision
variables (termed “linear programming problems”). Additionally, the
branch and bound algorithm can solve linear optimization problems that
contain only integer decision variables (termed “integer programming
problems”) and those that contain both integer and continuous decision
variables (termed “mixed integer programming problems”). These
algorithms have been applied to many different tasks, such as facility
location <span class="citation">(Canel &amp; Khumawala, 1996)</span>,
job scheduling <span class="citation">(Beaumont, 1997)</span>, and route
optimization <span class="citation">(Schouwenaars et al., 2001)</span>.
They are also becoming increasingly popular in conservation planning
<span class="citation">(Hanson et al., 2019; A. S. Rodrigues et al.,
2000; Schuster et al., 2020)</span>.</p>
<p>The <em>Where to Work</em> tool uses exact algorithms to generate
prioritizations. To achieve this, it formulates conservation planning
problems using the minimum set <span class="citation">(A. S. Rodrigues
et al., 2000)</span> or minimum shortfall <span class="citation">(Jung
et al., 2021)</span> reserve selection problems (depending on whether a
budget is specified or not) and then interfaces with external
optimization software to solve problems (termed “exact algorithm
solvers”). Currently, the <em>Where to Work</em> tool can use the <a href="https://www.gurobi.com/" class="external-link">Gurobi</a> and <a href="https://github.com/coin-or/Cbc" class="external-link">CBC</a> exact algorithm solvers
(note that Gurobi is not publicly available and only available with
advanced user access). Broadly speaking, these solvers often support
multiple different algorithms (e.g., they might support both the simplex
algorithm and branch and bound algorithm) so they can be applied to a
wide variety of optimization problems. For example, the Gurobi software
supports many different algorithms, including the branch and bound
algorithm, barrier algorithm, interior point algorithm and various
simplex algorithms (see <a href="https://www.gurobi.com/" class="external-link uri">https://www.gurobi.com/</a>). Additionally, exact algorithm
solvers may also use heuristic algorithms – a class of iterative
algorithms that do not guarantee optimality – in conjunction with other
algorithms to augment the optimization process <span class="citation">(e.g., Achterberg &amp; Berthold, 2007)</span>. They
may also apply presolve algorithms – a class of algorithms designed to
simplify and reduce the size of optimization problems – to speedup the
subsequent optimization process <span class="citation">(Achterberg et
al., 2020)</span>. Although it is beyond the scope of this article to
describe exactly which algorithms a particular solver will apply to a
given optimization problem, this has hopefully provided an overview of
the algorithms that they employ.</p>
</div>
<div class="section level2">
<h2 id="advantages-and-disadvantages-of-exact-algorithm-solvers">Advantages and disadvantages of exact algorithm solvers<a class="anchor" aria-label="anchor" href="#advantages-and-disadvantages-of-exact-algorithm-solvers"></a>
</h2>
<p>There are numerous advantages with using exact algorithm solvers. A
key advantage is that exact algorithms provide guarantees on solution
quality. For example, if required, they can solve problems to
optimality. In other words, they can identify the best possible solution
to a mathematical optimization problem. In real conservation decisions,
this can sometimes make a large difference in outcome <span class="citation">(Schuster et al., 2020)</span>. Solving to optimality
can also reassure decision makers that proposed solutions provide the
best possible outcomes, given the data and objectives they have entered
into the system. Also, if strict optimality is not required, they can
solve problems to within a pre-specified optimality gap (e.g., identify
a solution that is within 10% of optimality). This can be useful solvers
are often able to generate near optimal solutions much more quickly than
strictly optimal solutions, whilst still providing guarantees on
solution quality. Although other types of algorithms can be applied to
conservation problems <span class="citation">(Ciarleglio et al., 2008;
e.g., heuristic or meta-heuristic algorithms; J. B. Kirkpatrick, 1983;
S. Kirkpatrick et al., 1983; Nicholls &amp; Margules, 1993)</span>, they
do not provide such guarantees and, as such, may require re-running the
optimization process tens of thousands of times to verify solution
quality <span class="citation">(Ardron et al., 2010)</span>.
Additionally, exact algorithm solvers can be readily applied to a wide
variety of problems. Because the <em>Where to Work</em> tool uses exact
algorithm solvers, it can easily accommodate a variety of different
conservation planning problems. For instance, the <em>Where to Work</em>
tool can be used to generate (i) prioritizations that minimize cost
whilst ensuring all goals are met (i.e., a “minimum set reserve
selection problem”) and (ii) prioritizations that aim to reach as many
goals as possible, whilst ensuring that the total selected area does not
exceed a pre-specified budget (i.e., a “budget-limited reserve selection
problem”). Furthermore, another advantage of using exact algorithm
solvers is that they are steadily increasing in performance over time
<span class="citation">(Achterberg &amp; Wunderling, 2013)</span>. By
interfacing with exact algorithm solvers, this means that the <em>Where
to Work</em> tool leverages such improvements as newer versions of the
solvers become available over time.</p>
<p>There are also several disadvantages with using exact algorithm
solvers. A key disadvantage is that the best performing exact algorithm
solvers are commercial software (e.g., <a href="https://www.gurobi.com/" class="external-link">Gurobi</a> and <a href="https://www.ibm.com/products/ilog-cplex-optimization-studio" class="external-link">IBM
CPLEX</a>). Although open source exact algorithm solvers are available
(e.g., <a href="https://github.com/coin-or/Cbc" class="external-link">CBC</a>, <a href="https://highs.dev/" class="external-link">HiGHS</a>, and <a href="https://github.com/coin-or/SYMPHONY" class="external-link">SYMPHONY</a>), they generally
cannot solve optimization problems as quickly as the commercial solvers
and they might not be able to solve particularly large problems <span class="citation">(Schuster et al., 2020)</span>. Commercial solvers
often provide special free licenses for academic use (e.g., <a href="https://www.gurobi.com/academia/academic-program-and-licenses/" class="external-link">Gurobi</a>
and <a href="https://www.ibm.com/support/pages/ibm-ilog-optimization-academic-initiative" class="external-link">IBM
CPLEX</a>); however, commercial licenses may be required for use by
governmental, commercial, and non-governmental organizations. As such,
organizations may need to carefully consider the potential benefits and
costs associated with using commercial solvers. Another disadvantage is
that exact algorithms can be much slower than other types of algorithms.
For example, some heuristic algorithms – while they cannot guarantee
solution quality – can generate near-optimal solutions to optimization
problems faster than exact algorithms <span class="citation">(Pressey et
al., 1997; Zanakis &amp; Evans, 1981)</span>. Indeed, the Zonation
decision support tool – which is powered by iterative algorithms <span class="citation">(Moilanen et al., 2022)</span> – can likely solve
budget-limited reserve selection problems faster than the <em>Where to
Work</em> tool. Finally, it can be challenging to solve large-scale
non-linear problems with exact algorithms [e.g., problems that include
complex metrics for connectivity; <span class="citation">Keeley et al.
(2021)</span>]. Although this means that they might not be able to solve
particularly complex mathematical optimization problems <span class="citation">(Moilanen, 2008)</span>, exact algorithm solvers can be
applied to many conservation planning problems <span class="citation">(e.g., Hanson et al., 2019; A. S. Rodrigues et al.,
2000)</span>.</p>
</div>
<div class="section level2">
<h2 id="explanation-of-how-an-exact-algorithm-works">Explanation of how an exact algorithm works<a class="anchor" aria-label="anchor" href="#explanation-of-how-an-exact-algorithm-works"></a>
</h2>
<p>Here we will explain how the branch and bound algorithm – one of the
earliest exact algorithms – can be used to solve optimization problems
<span class="citation">(Land &amp; Doig, 1960)</span>. The main aim of
this section is to explain how it is possible for an algorithm to
guarantee optimality, without iterating over every single possible
solution. Since this article is intended for an audience that does not
have a strong mathematical background, we will only provide basic
understanding of the algorithm.</p>
<p>For ease of interpretation, we will begin with an intuitive
description. The branch and bound algorithm involves iteratively
subdividing an optimization problem into a hierarchical tree of
sub-problems. Here, the base (or stump) is the original optimization
problem, each branch is a different sub-problem, and the tips of the
branches are different solutions to the original problem. By exploiting
the hierarchical structure of the tree, the algorithm can effectively
search for an optimal solution without having to examine each and every
possible solution (i.e., tip). Indeed, the algorithm can examine
particular branches and determine if an optimal solution will not be
found in any of the tips connected to the branch. The algorithm
terminates once it has explored enough of the tree to identify an
optimal solution to the original problem. Hopefully, this intuitive
description is useful. However, if further details are required, we will
provide a more thorough description below.</p>
<p>We will define some terminology to aid in describing the algorithm.
An <em>objective value</em> is a measure that quantifies the quality of
a candidate solution (e.g., the cost of a set of a prioritization, or
how well a prioritization safeguards a variety of species). Also, an
<em>optimal solution</em> is a solution which has the best possible
objective value to a particular problem, whilst meeting all the
constraints (e.g., the cost for a prioritization must be below a
particular budget threshold) and variable restrictions (e.g., particular
variables such as “purchase” or “do not purchase” must be integer or
binary) defined for the problem. Additionally, an <em>incumbent
solution</em> is the best solution found so far during the course of an
optimization process, which is sometimes initially estimated using a
heuristic algorithm. Finally, a <em>bound for the optimal solution</em>
is the best estimate for the objective value of the optimal solution.
During the course of an optimization process, the <em>bound for the
optimal solution</em> will become more accurate. Also, note that the
<em>bound for the optimal solution</em> is mathematically defined to be
equal to, or better than, the objective value of the optimal solution
(e.g., in a maximization problem, it will be greater than the objective
value of the optimal solution). After defining these terms, we can begin
describing the branch and bound algorithm in more detail.</p>
<p>The branch and bound algorithm starts by solving a relaxed version of
the original optimization problem. In particular, a problem that
contains integer (or binary) variables can be relaxed to create a new
problem by substituting the integer (or binary) variables for continuous
variables. For example, if we had a problem that contained an integer
variable ranging between 1 and 5, the relaxed version of this problem
could contain a new continuous variable ranging between 1.0 and 5.0.
Since problems that contain only continuous variables are much easier to
solve, the relaxed problem can be solved relatively quickly. If the
solution to the relaxed problem meets the integer (or binary)
restrictions to the original problem, then the <em>optimal solution</em>
to the original problem has been found. However, this is rarely the
case.</p>
<p>The solution to the relaxed problem will likely contain non-integer
(or non-binary) values for the integer (or binary) variables. As such,
the solution to the relaxed problem is not considered <em>feasible</em>
(because it contains non-integer values for “purchase” or “do not
purchase” variables that must contain integer or binary values), and it
is not the <em>optimal solution</em> to the original problem. However,
this does not mean that the solution is useless. Because the
<em>objective value</em> for the solution to the relaxed problem will
always be better than (or equal to) the <em>objective value</em> for the
<em>optimal solution</em> to the original solution, the <em>objective
value</em> for the solution to the relaxed problem can be used to set an
initial estimate for the <em>bound for the optimal solution</em>. As we
will see in subsequent procedures, the <em>bound for the optimal
solution</em> will be updated and refined during the course of the
optimization process.</p>
<p>The solution to the relaxed problem can be used to subdivide the
relaxed problem into a series of sub-problems. These sub-problems can be
viewed as hierarchically subordinate “children” to the “parent” problem.
For example, if the solution to the relaxed problem has a value of 4.3
for an integer variable, then this variable could be used to create two
sub-problems by (i) adding a constraint specifying this variable must be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">&lt;= 4</annotation></semantics></math>
and (ii) adding a constraint specifying this variable must be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">&gt;= 5</annotation></semantics></math>.
If the solution to the relaxed problem contains many values that do not
meet the integer (or binary) restrictions for the variables, there might
be a very large number of sub-problems. The algorithm will then decide
on a particular sub-problem to explore further. Indeed, the methods used
to determine which sub-problem to explore further have an enormous
impact on run time, and fast exact algorithm solvers will have
algorithms dedicated to help speed up this process.</p>
<p>The algorithm will then solve the chosen sub-problem. Although the
sub-problem has one (or potentially multiple) additional constraint(s),
it is still a relaxed version of the original problem and can be solved
relatively quickly. Depending on the solution to the sub-problem, one of
the three following procedures will be applied. First, if (i) the
solution to the sub-problem contains values that meet all the integer
(or binary) restrictions for the variables and (ii) the objective value
for the solution is better than the <em>objective value for the
incumbent solution</em>, then the solution is earmarked as the new
<em>incumbent solution</em>. Second, if (i) the solution to the
sub-problem contains values that do not meet all the integer (or binary)
restrictions for the variables and (ii) the objective value for the
solution does not provide a better <em>bound for the optimal
solution</em>, then the sub-problem is abandoned and another sub-problem
is selected as a chosen sub-problem. Third, if (i) the solution to the
sub-problem contains values that do not meet all the integer (or binary)
restrictions for the variables and (ii) the objective value for the
solution provides a better <em>bound for the optimal solution</em>, then
the objective value for the solution is used to update the <em>bound for
the optimal solution</em> and the sub-problem is subdivided into further
sub-sub-problems. One of these sub-sub-problems is then selected as the
new chosen sub-problem, and the procedures previously outlined in this
paragraph are applied, recursively, to the new chosen sub-problem.</p>
<p>During the course of the optimization process, the <em>bound for the
optimal solution</em> and the <em>objective value</em> for the
<em>incumbent solution</em> will become more similar to each other.
Indeed, as sub-problems are solved to obtain better estimates of the
<em>bound for the optimal solution</em>, the <em>bound for the optimal
solution</em> will get closer to the <em>objective value</em> for the
<em>incumbent solution</em>. Additionally, as sub-problems are solved to
obtain better quality <em>feasible</em> solutions, the <em>objective
value</em> for the <em>incumbent solution</em> will improve. For
example, in a maximization problem, the <em>bound for the optimal
solution</em> will typically start with a relatively high value (i.e.,
reflecting an overly high initial estimate of the optimal <em>objective
value</em>) and decrease as sub-problems are explored and the bound is
refined. Whereas, the <em>objective value</em> for the <em>incumbent
solution</em> will start with a low value (i.e., reflecting a poor
quality solution to the original optimization problem) and increase as
solving sub-problems yields better quality <em>feasible</em>
solutions.</p>
<p>The algorithm terminates when the <em>bound for the optimal
solution</em> and the <em>objective value</em> for the <em>incumbent
solution</em> both have very similar values. In particular, the
algorithm will terminate when the relative difference expressed as a
percentage (i.e., optimality gap) between the <em>bound for the optimal
solution</em> and the <em>objective value</em> for the <em>incumbent
solution</em> meets a pre-specified threshold. For example, if a 0%
optimality gap is specified, then the algorithm terminates when the
<em>bound for the optimal solution</em> and the <em>objective value for
the incumbent solution</em> are equal to each other. The <em>Where to
Work</em> tool applies a two stage optimization process, where it uses
an optimality gap of 10% in the first stage where it focuses on
maximizing species’ representation or minimizing cost (if using a budget
or not, receptively) and an optimality gap of 15% to subsequently
minimize spatial fragmentation (if specified). When the algorithm
terminates, it will output the <em>incumbent solution</em>. This is
because the <em>incumbent solution</em> is the best solution found that
meets the integer (or binary) restrictions for the variables.</p>
</div>
<div class="section level2">
<h2 id="resources-for-learning-more-about-exact-algorithms">Resources for learning more about exact algorithms<a class="anchor" aria-label="anchor" href="#resources-for-learning-more-about-exact-algorithms"></a>
</h2>
<p>Here we will provide resources for learning more about exact
algorithms. In particular, Gurobi Optimization – the developer of the <a href="https://www.gurobi.com/" class="external-link">Gurobi exact algorithm solver</a> – has
created numerous online resources to help its users understand exact
algorithms. These resources include <a href="https://www.gurobi.com/resource-center/" class="external-link">online guides</a> and <a href="https://www.youtube.com/@GurobiVideos" class="external-link">videos</a>. They have been
created by experts in mathematical optimization and provide detailed
explanations. Among these resources is a <a href="https://www.youtube.com/watch?v=mUjkCeLx6_4&amp;list=PLHiHZENG6W8Dt7ub1H1RsF4xXB_YtxXv-&amp;pp=iAQB" class="external-link">webinar
series on using exact algorithms to solve mixed integer programming
problems (i.e., those that contain both continuous and integer (or
binary variables)</a> and a <a href="https://www.youtube.com/watch?v=U-2CdTe-j2Q&amp;list=PLHiHZENG6W8BeAfJfZ3myo5dsSQjEV5pJ&amp;pp=iAQB" class="external-link">webinar
series on using exact algorithms to solve linear programming problems
(i.e., those that contain only continuous variables)</a>. Although
watching both of these webinar series will be useful for better
understanding the algorithms that underpin the <em>Where to Work</em>
tool, readers that are interested in an illustrative example of the
branch and bound algorithm (discussed in the previous section) may find
the <a href="https://youtu.be/CdfZ4XOpSho?list=PLHiHZENG6W8Dt7ub1H1RsF4xXB_YtxXv-" class="external-link">video
on this algorithm</a> of particular interest.</p>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0" line-spacing="2">
<div id="ref-r27" class="csl-entry">
Achterberg, T., &amp; Berthold, T. (2007). Improving the feasibility
pump. <em>Discrete Optimization</em>, <em>4</em>(1), 77–86.
</div>
<div id="ref-r26" class="csl-entry">
Achterberg, T., Bixby, R. E., Gu, Z., Rothberg, E., &amp; Weninger, D.
(2020). Presolve reductions in mixed integer programming. <em>INFORMS
Journal on Computing</em>, <em>32</em>(2), 473–506.
</div>
<div id="ref-r20" class="csl-entry">
Achterberg, T., &amp; Wunderling, R. (2013). <span class="nocase">Mixed
Integer Programming: Analyzing 12 Years of Progress</span>. In M. Jünger
&amp; G. Reinelt (Eds.), <em>Facets of combinatorial optimization:
Festschrift for martin gr<span>ö</span>tschel</em> (pp. 449–481).
Springer.
</div>
<div id="ref-r21" class="csl-entry">
Ardron, J. A., Possingham, H. P., &amp; Klein, C. J. (2010).
<em><span>Marxan Good Practices Handbook </span></em> ((2nd version)).
Pacific Marine Analysis; Research Association.
</div>
<div id="ref-r11" class="csl-entry">
Beaumont, N. (1997). Scheduling staff using mixed integer programming.
<em>European Journal of Operational Research</em>, <em>98</em>(3),
473–484.
</div>
<div id="ref-r10" class="csl-entry">
Canel, C., &amp; Khumawala, B. M. (1996). A mixed-integer programming
approach for the international facilities location problem.
<em>International Journal of Operations and Production Management</em>,
<em>16</em>(4), 49–68.
</div>
<div id="ref-r25" class="csl-entry">
Ciarleglio, M., Barnes, J. W., &amp; Sarkar, S. (2008). <span class="nocase">ConsNet—A tabu search approach to the spatially coherent
conservation area network design problem</span>. <em>Journal of
Heuristics</em>, <em>16</em>(4), 537–557.
</div>
<div id="ref-r6" class="csl-entry">
Dantzig, G. B. (1951). Maximization of a linear function of variables
subject to linear inequalities. In <em><span class="nocase">Activity
Analysis of Production and Allocation—Proceedings of a
Conference</span></em> (Vol. 13, pp. 339–334). Wiley.
</div>
<div id="ref-r9" class="csl-entry">
Dikin, I. I. (1967). Iterative solution of problems of linear and
quadratic programming. <em>Doklady Akademii Nauk</em>, <em>174</em>(4),
747–748.
</div>
<div id="ref-r14" class="csl-entry">
Hanson, J. O., Schuster, R., Strimas‐Mackey, M., &amp; Bennett, J. R.
(2019). Optimality in prioritizing conservation projects. <em>Methods in
Ecology and Evolution</em>, <em>10</em>(10), 1655–1663.
</div>
<div id="ref-r28" class="csl-entry">
Jung, M., Arnell, A., Lamo, X. de, García-Rangel, S., Lewis, M., Mark,
J., Merow, C., Miles, L., Ondo, I., Pironon, S., Ravilious, C., Rivers,
M., Schepaschenko, D., Tallowin, O., Soesbergen, A. van, Govaerts, R.,
Boyle, B. L., Enquist, B. J., Feng, X., … Visconti, P. (2021). Areas of
global importance for conserving terrestrial biodiversity, carbon and
water. <em>Nature Ecology &amp;Amp; Evolution</em>, <em>5</em>(11),
1499–1509.
</div>
<div id="ref-r29" class="csl-entry">
Keeley, A. T. H., Beier, P., &amp; Jenness, J. S. (2021). Connectivity
metrics for conservation planning and monitoring. <em>Biological
Conservation</em>, <em>255</em>, 109008. <a href="http://dx.doi.org/10.1016/j.biocon.2021.109008" class="external-link">http://dx.doi.org/10.1016/j.biocon.2021.109008</a>
</div>
<div id="ref-r22" class="csl-entry">
Kirkpatrick, J. B. (1983). An iterative method for establishing
priorities for the selection of nature reserves: An example from
tasmania. <em>Biological Conservation</em>, <em>25</em>(2), 127–134.
</div>
<div id="ref-r23" class="csl-entry">
Kirkpatrick, S., Gelatt, C. D., &amp; Vecchi, M. P. (1983). Optimization
by simulated annealing. <em>Science</em>, <em>220</em>(4598), 671–680.
</div>
<div id="ref-r7" class="csl-entry">
Land, A. H., &amp; Doig, A. G. (1960). An automatic method of solving
discrete programming problems. <em>Econometrica</em>, <em>28</em>(3),
497–520.
</div>
<div id="ref-r19" class="csl-entry">
Moilanen, A. (2008). Two paths to a suboptimal solution – once more
about optimality in reserve selection. <em>Biological Conservation</em>,
<em>141</em>(7), 1919–1923.
</div>
<div id="ref-r18" class="csl-entry">
Moilanen, A., Lehtinen, P., Kohonen, I., Jalkanen, J., Virtanen, E. A.,
&amp; Kujala, H. (2022). Novel methods for spatial prioritization with
applications in conservation, land use planning and ecological impact
avoidance. <em>Methods in Ecology and Evolution</em>, <em>13</em>(5),
1062–1072.
</div>
<div id="ref-r24" class="csl-entry">
Nicholls, A. O., &amp; Margules, C. R. (1993). An upgraded reserve
selection algorithm. <em>Biological Conservation</em>, <em>64</em>(2),
165–169.
</div>
<div id="ref-r8" class="csl-entry">
Padberg, M., &amp; Giovanni, R. (1991). A branch-and-cut algorithm for
the resolution of large-scale symmetric traveling salesman problems.
<em>SIAM Review</em>, <em>33</em>(1), 497–520.
</div>
<div id="ref-r17" class="csl-entry">
Pressey, R. L., Possingham, H. P., &amp; Day, J. R. (1997).
Effectiveness of alternative heuristic algorithms for identifying
indicative minimum requirements for conservation reserves.
<em>Biological Conservation</em>, <em>80</em>(2), 207–219.
</div>
<div id="ref-r4" class="csl-entry">
Rodrigues, A. S. L., &amp; Gaston, K. J. (2002). Optimisation in reserve
selection procedures—why not? <em>Biological Conservation</em>,
<em>107</em>(1), 123–129.
</div>
<div id="ref-r13" class="csl-entry">
Rodrigues, A. S., Orestes Cerdeira, J., &amp; Gaston, K. J. (2000).
Flexibility, efficiency, and accountability: Adapting reserve selection
algorithms to more complex conservation problems. <em>Ecography</em>,
<em>23</em>(5), 565–574.
</div>
<div id="ref-r12" class="csl-entry">
Schouwenaars, T., De Moor, B., Feron, E., &amp; How, J. (2001). Mixed
integer programming for multi-vehicle path planning. In <em><span>2001
European Control Conference (ECC)</span></em> (pp. 2603–2608). Porto,
Portugal. <a href="https://doi.org/10.23919/ECC.2001.7076321" class="external-link">https://doi.org/10.23919/ECC.2001.7076321</a>
</div>
<div id="ref-r15" class="csl-entry">
Schuster, R., Hanson, J. O., Strimas-Mackey, M., &amp; Bennett, J. R.
(2020). Exact integer linear programming solvers outperform simulated
annealing for solving conservation planning problems. <em>PeerJ</em>,
<em>8</em>, e9258.
</div>
<div id="ref-r5" class="csl-entry">
Underhill, L. G. (1994). Optimal and suboptimal reserve selection
algorithms. <em>Biological Conservation</em>, <em>70</em>(1), 85–87.
</div>
<div id="ref-r16" class="csl-entry">
Zanakis, S. H., &amp; Evans, J. R. (1981). Heuristic "optimization",
why, when, and how to use it. <em>Interfaces</em>, <em>11</em>(5),
84–91.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Jeffrey O Hanson, Richard Schuster, Joseph Bennett, Jaimie Vincent.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
